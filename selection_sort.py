# coding: utf-8

"""
Сортировка выбором (Selection sort)

Поиск наименьшего или наибольшего элемента и помещение его в начало или конец упорядоченного списка.

Может быть как устойчивый, так и неустойчивый.

На массиве из n элементов имеет время выполнения в худшем, среднем и лучшем случае Θ(n2),
предполагая что сравнения делаются за постоянное время.

Шаги алгоритма:

1. находим номер минимального значения в текущем списке
2. производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен,
   если минимальный элемент уже находится на данной позиции)
3. теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы

Для реализации устойчивости алгоритма необходимо в пункте 2 минимальный элемент непосредственно вставлять
в первую неотсортированную позицию, не меняя порядок остальных элементов.

http://ru.wikipedia.org/wiki/Сортировка_выбором
"""


def swap(arr, i1, i2):
    """Функция меняет местами элементы массива"""
    temp = arr[i1]
    arr[i1] = arr[i2]
    arr[i2] = temp


def selection_sort(arr):
    """Сортировка выбором"""

    # кол-во элементов в последовательности
    n = len(arr)

    # i - позиция неотсортированного элемента на данной итерации
    for i in xrange(n):
        k = i  # k - позиция минимального элемента

        # j - позиция элемента который возможно меньше элемента arr[i]
        for j in xrange(i+1, n):
            if arr[j] < arr[k]:
                k = j
        if k != i:
            swap(arr, k, i)
    return arr


import time
import random

arr = list(range(10000))
random.shuffle(arr)

start_cpu = time.clock()
start_real = time.time()

out = selection_sort(arr)

end_cpu = time.clock()
end_real = time.time()

print 'Тест: %s' % (out[:20] == list(range(20)))
print 'Процессорное время в секундах %f' % (end_cpu - start_cpu)
print 'Действительное время в секундах %f' % (end_real - start_real)
