# coding: utf-8

"""
Сортировка выбором (Selection sort)

Поиск наименьшего или наибольшего элемента и помещение его в начало или конец упорядоченного списка.

Может быть как устойчивый, так и неустойчивый.

На массиве из n элементов имеет время выполнения в худшем, среднем и лучшем случае Θ(n2),
предполагая что сравнения делаются за постоянное время.

Шаги алгоритма:

1. находим номер минимального значения в текущем списке
2. производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен,
   если минимальный элемент уже находится на данной позиции)
3. теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы

Для реализации устойчивости алгоритма необходимо в пункте 2 минимальный элемент непосредственно вставлять
в первую неотсортированную позицию, не меняя порядок остальных элементов.

http://ru.wikipedia.org/wiki/Сортировка_выбором
"""


def selection_sort(it):
    """Алгоритм без дополнительного выделения памяти"""

    # внешний цикл, i – позиция первого неотсортированного элемента на данной итерации
    for i in range(len(it)):
        k = i  # k – позиция минимального элемента

        # внутренний цикл, если найден элемент строго меньший текущего минимального,
        # записываем его индекс как минимальный
        for j in range(i + 1, len(it)):
            if it[j] < it[k]:
                k = j

        # минимальный элемент не является первым неотсортированным, обмен нужен
        if k != i:
            temp = it[i]
            it[i] = it[k]
            it[k] = temp
    return it


import time
import random

inp = list(range(10000))
random.shuffle(inp)

start_cpu = time.clock()
start_real = time.time()

out = selection_sort(inp)

end_cpu = time.clock()
end_real = time.time()

print 'Тест: %s' % (out[:20] == list(range(20)))
print 'Процессорное время в секундах %f' % (end_cpu - start_cpu)
print 'Действительное время в секундах %f' % (end_real - start_real)
